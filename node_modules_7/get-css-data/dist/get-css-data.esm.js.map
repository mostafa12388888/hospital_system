{"version":3,"file":"get-css-data.esm.js","sources":["../src/get-urls.js","../src/get-css.js"],"sourcesContent":["/*global XDomainRequest*/\n\n// Functions\n// =============================================================================\n/**\n * Requests one-or-more URLs and returns array of data in order specified.\n * Provides callbacks error and success callbacks for each XMLHttpRequest.\n *\n * @param {array|string} url Single URL or array of URLs to request\n * @param {object}      [options] Options object\n * @param {string}      [options.mimeType] Overrides MIME type returned by\n *                      server\n * @param {function}    [options.onBeforeSend] Callback before each request is\n *                      sent. Passes 1) the xhr object, 2) the URL, and 3) the\n *                      URL index as arguments.\n * @param {function}    [options.onSuccess] Callback on xhr success. Passes 1)\n *                      xhr response text, 2) the URL, and 3) the URL index as\n *                      arguments.\n * @param {function}    [options.onError] Callback on xhr error. Passes 1) the\n *                      xhr object, 2) the URL, 3) the URL index as arguments.\n * @param {function}    [options.onComplete] Callback after all requests have\n *                      completed. Passes 1) an array of response text for each\n *                      URL in order provided as an argument.\n */\nfunction getUrls(urls, options = {}) {\n    const settings = {\n        mimeType    : options.mimeType     || null,\n        onBeforeSend: options.onBeforeSend || Function.prototype,\n        onSuccess   : options.onSuccess    || Function.prototype,\n        onError     : options.onError      || Function.prototype,\n        onComplete  : options.onComplete   || Function.prototype\n    };\n    const urlArray = Array.isArray(urls) ? urls : [urls];\n    const urlQueue = Array.apply(null, Array(urlArray.length)).map(x => null);\n\n    // Functions (Private)\n    // -------------------------------------------------------------------------\n    function isValidCss(text) {\n        const isString = typeof text === 'string';\n        const isHTML = isString && text.trim().charAt(0) === '<';\n\n        return isString && !isHTML;\n    }\n\n    function onError(xhr, urlIndex) {\n        settings.onError(xhr, urlArray[urlIndex], urlIndex);\n    }\n\n    function onSuccess(responseText, urlIndex) {\n        const returnVal = settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);\n\n        responseText = returnVal === false ? '' : returnVal || responseText;\n        urlQueue[urlIndex] = responseText;\n\n        // Complete\n        if (urlQueue.indexOf(null) === -1) {\n            settings.onComplete(urlQueue);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    const parser = document.createElement('a');\n\n    urlArray.forEach((url, i) => {\n        parser.setAttribute('href', url);\n        parser.href = String(parser.href);\n\n        const isIElte9     = Boolean(document.all && !window.atob);\n        const isIElte9CORS = isIElte9 && parser.host.split(':')[0] !== location.host.split(':')[0];\n\n        // IE 9 CORS\n        if (isIElte9CORS) {\n            const isSameProtocol = parser.protocol === location.protocol;\n\n            if (isSameProtocol) {\n                const xdr = new XDomainRequest();\n\n                // Event handlers must be assigned AFTER xdr.open\n                xdr.open('GET', url);\n\n                xdr.timeout = 0; // Prevent aborts/timeouts\n                xdr.onprogress = Function.prototype; // Prevent aborts/timeouts\n                xdr.ontimeout = Function.prototype; // Prevent aborts/timeouts\n                xdr.onload = function() {\n                    const text = xdr.responseText;\n\n                    if (isValidCss(text)) {\n                        onSuccess(text, i);\n                    }\n                    else {\n                        onError(xdr, i);\n                    }\n                };\n                xdr.onerror = function(err) {\n                    onError(xdr, i);\n                };\n\n                // Wrap in setTimeout to fix known issues with XDomainRequest\n                // when sending multiple requests\n                setTimeout(function() {\n                    xdr.send();\n                }, 0);\n            }\n            else {\n                // eslint-disable-next-line\n                console.warn(`Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol (${url})`);\n                onError(null, i);\n            }\n        }\n        // Other\n        else {\n            const xhr = new XMLHttpRequest();\n\n            xhr.open('GET', url);\n\n            // overrideMimeType method not available in all browsers\n            if (settings.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(settings.mimeType);\n            }\n\n            settings.onBeforeSend(xhr, url, i);\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    const text = xhr.responseText;\n\n                    // Success\n                    if (xhr.status < 400 && isValidCss(text)) {\n                        onSuccess(text, i);\n                    }\n                    // Success via file protocol (file://)\n                    else if (xhr.status === 0 && isValidCss(text)) {\n                        onSuccess(text, i);\n                    }\n                    // Error\n                    else {\n                        onError(xhr, i);\n                    }\n                }\n            };\n\n            xhr.send();\n        }\n    });\n}\n\n\n// Export\n// =============================================================================\nexport default getUrls;\n","// Dependencies\n// =============================================================================\nimport getUrls from './get-urls';\n\n\n// Functions (Public)\n// =============================================================================\n/**\n * Gets CSS data from <style> and <link> nodes (including @imports), then\n * returns data in order processed by DOM. Allows specifying nodes to\n * include/exclude and filtering CSS data using RegEx.\n *\n * @preserve\n * @param {object}   [options] The options object\n * @param {object}   [options.rootElement=document] Root element to traverse for\n *                   <link> and <style> nodes.\n * @param {string}   [options.include] CSS selector matching <link> and <style>\n *                   nodes to include\n * @param {string}   [options.exclude] CSS selector matching <link> and <style>\n *                   nodes to exclude\n * @param {object}   [options.filter] Regular expression used to filter node CSS\n *                   data. Each block of CSS data is tested against the filter,\n *                   and only matching data is included.\n * @param {boolean}  [options.skipDisabled=true] Determines if disabled\n *                   stylesheets will be skipped while collecting CSS data.\n * @param {boolean}  [options.useCSSOM=false] Determines if CSS data will be\n *                   collected from a stylesheet's runtime values instead of its\n *                   text content. This is required to get accurate CSS data\n *                   when a stylesheet has been modified using the deleteRule()\n *                   or insertRule() methods because these modifications will\n *                   not be reflected in the stylesheet's text content.\n * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes\n *                   1) the XHR object, 2) source node reference, and 3) the\n *                   source URL as arguments.\n * @param {function} [options.onSuccess] Callback on each CSS node read. Passes\n *                   1) CSS text, 2) source node reference, and 3) the source\n *                   URL as arguments.\n * @param {function} [options.onError] Callback on each error. Passes 1) the XHR\n *                   object for inspection, 2) soure node reference, and 3) the\n *                   source URL that failed (either a <link> href or an @import)\n *                   as arguments\n * @param {function} [options.onComplete] Callback after all nodes have been\n *                   processed. Passes 1) concatenated CSS text, 2) an array of\n *                   CSS text in DOM order, and 3) an array of nodes in DOM\n *                   order as arguments.\n *\n * @example\n *\n *   getCssData({\n *     rootElement : document,\n *     include     : 'style,link[rel=\"stylesheet\"]',\n *     exclude     : '[href=\"skip.css\"]',\n *     filter      : /red/,\n *     skipDisabled: true,\n *     useCSSOM    : false,\n *     onBeforeSend(xhr, node, url) {\n *       // ...\n *     }\n *     onSuccess(cssText, node, url) {\n *       // ...\n *     }\n *     onError(xhr, node, url) {\n *       // ...\n *     },\n *     onComplete(cssText, cssArray, nodeArray) {\n *       // ...\n *     }\n *   });\n */\nfunction getCssData(options) {\n    const regex = {\n        // CSS comments\n        cssComments: /\\/\\*[\\s\\S]+?\\*\\//g,\n        // CSS @import rules ($1: url)\n        cssImports : /(?:@import\\s*)(?:url\\(\\s*)?(?:['\"])([^'\"]*)(?:['\"])(?:\\s*\\))?(?:[^;]*;)/g\n    };\n    const settings = {\n        rootElement : options.rootElement  || document,\n        include     : options.include      || 'style,link[rel=\"stylesheet\"]',\n        exclude     : options.exclude      || null,\n        filter      : options.filter       || null,\n        skipDisabled: options.skipDisabled !== false,\n        useCSSOM    : options.useCSSOM     || false,\n        onBeforeSend: options.onBeforeSend || Function.prototype,\n        onSuccess   : options.onSuccess    || Function.prototype,\n        onError     : options.onError      || Function.prototype,\n        onComplete  : options.onComplete   || Function.prototype\n    };\n    const sourceNodes = Array.apply(null, settings.rootElement.querySelectorAll(settings.include)).filter(node => !matchesSelector(node, settings.exclude));\n    const cssArray    = Array.apply(null, Array(sourceNodes.length)).map(x => null);\n\n    /**\n     * Handles the onComplete() callback after verifying that all CSS has been\n     * processed.\n     */\n    function handleComplete() {\n        const isComplete = cssArray.indexOf(null) === -1;\n\n        if (isComplete) {\n            // Remove skipped nodes/css\n            cssArray\n                .reduce((skipIndices, value, i) => {\n                    if (value === '') {\n                        skipIndices.push(i);\n                    }\n\n                    return skipIndices;\n                }, [])\n                .reverse()\n                .forEach(skipIndex => [sourceNodes, cssArray].forEach(arr => arr.splice(skipIndex, 1)));\n\n            const cssText = cssArray.join('');\n\n            settings.onComplete(cssText, cssArray, sourceNodes);\n        }\n    }\n\n    /**\n     * Processes CSS text, updates cssArray, and triggers handleComplete()\n     * 1. Passes CSS to resolveImports\n     * 2. Triggers onError() callback for each @import error\n     * 3. Tests resolved CSS against (optional) RegEx filter\n     * 4. Triggers onSuccess() callback and accepts modified cssText as return\n     * 5. Inserts final CSS into cssArray\n     * 6. Triggers handleComplete() after processing is complete\n     *\n     * @param {string} cssText CSS text to be processed\n     * @param {number} cssIndex cssArray index to store final CSS\n     * @param {object} node CSS source <link> or <style> node\n     * @param {string} sourceUrl The URL containing the source node\n     */\n    function handleSuccess(cssText, cssIndex, node, sourceUrl) {\n        const returnVal = settings.onSuccess(cssText, node, sourceUrl);\n\n        cssText = returnVal !== undefined && Boolean(returnVal) === false ? '' : returnVal || cssText;\n\n        resolveImports(cssText, node, sourceUrl, function(resolvedCssText, errorData) {\n            if (cssArray[cssIndex] === null) {\n                // Trigger onError for each error item\n                errorData.forEach(data => settings.onError(data.xhr, node, data.url));\n\n                // Filter: Pass\n                if (!settings.filter || settings.filter.test(resolvedCssText)) {\n                    cssArray[cssIndex] = resolvedCssText;\n                }\n                // Filter: Fail\n                else {\n                    cssArray[cssIndex] = '';\n                }\n\n                handleComplete();\n            }\n        });\n    }\n\n    /**\n     * Parses CSS and returns an object containing @import related data.\n     *\n     * @param {any} cssText CSS text to be processed\n     * @param {any} baseUrl Base URL used to resolve relative @import URLs\n     * @param {any} [ignoreRules=[]]\n     * @returns {object}\n     */\n    function parseImportData(cssText, baseUrl, ignoreRules = []) {\n        const importData = {};\n\n        // @import rules\n        // Ex: @import \"file.css\";\n        importData.rules = (cssText\n            // Remove comments to avoid processing @import in comments\n            .replace(regex.cssComments, '')\n            // Find all @import rules\n            .match(regex.cssImports)\n            // Force empty array if no match\n            || [])\n            // Remove rules found in ignoreRules array\n            .filter(rule => ignoreRules.indexOf(rule) === -1);\n\n        // @import urls\n        // Ex: file.css\n        importData.urls = importData.rules.map(rule => rule.replace(regex.cssImports, '$1'));\n\n        // Absolute @import urls\n        // Ex: /path/to/file.css\n        importData.absoluteUrls = importData.urls.map(url => getFullUrl(url, baseUrl));\n\n        // Absolute @import rules\n        // Ex: @import \"/path/to/file.css\";\n        importData.absoluteRules = importData.rules.map((rule, i) => {\n            const oldUrl = importData.urls[i];\n            const newUrl = getFullUrl(importData.absoluteUrls[i], baseUrl);\n\n            return rule.replace(oldUrl, newUrl);\n        });\n\n        return importData;\n    }\n\n    /**\n     * Recursively parses CSS for @import rules, fetches data for each import\n     * URL, replaces the @rule the fetched data, then returns the resolved CSS\n     * via a callback function.\n     *\n     * @param {string}   cssText CSS text to be processed\n     * @param {object}   node CSS source <link> or <style> node\n     * @param {string}   baseUrl Base URL used to resolve relative @import URLs\n     * @param {function} callbackFn Callback function to trigger on complete.\n     *                   Passes 1) the resolves CSS and 2) an array of error\n     *                   objects as arguments.\n     */\n    function resolveImports(cssText, node, baseUrl, callbackFn, __errorData = [], __errorRules = []) {\n        const importData = parseImportData(cssText, baseUrl, __errorRules);\n\n        // Has @imports\n        if (importData.rules.length) {\n            getUrls(importData.absoluteUrls, {\n                onBeforeSend(xhr, url, urlIndex) {\n                    settings.onBeforeSend(xhr, node, url);\n                },\n                onSuccess(cssText, url, urlIndex) {\n                    const returnVal = settings.onSuccess(cssText, node, url);\n\n                    cssText = returnVal === false ? '' : returnVal || cssText;\n\n                    const responseImportData = parseImportData(cssText, url, __errorRules);\n\n                    // Replace relative @import rules with absolute rules\n                    responseImportData.rules.forEach((rule, i) => {\n                        cssText = cssText.replace(rule, responseImportData.absoluteRules[i]);\n                    });\n\n                    return cssText;\n                },\n                onError(xhr, url, urlIndex) {\n                    __errorData.push({ xhr, url });\n                    __errorRules.push(importData.rules[urlIndex]);\n\n                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);\n                },\n                onComplete(responseArray) {\n                    responseArray.forEach((importText, i) => {\n                        cssText = cssText.replace(importData.rules[i], importText);\n                    });\n\n                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);\n                }\n            });\n        }\n        // No @imports\n        else {\n            callbackFn(cssText, __errorData);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    if (sourceNodes.length) {\n        sourceNodes.forEach((node, i) => {\n            const linkHref = node.getAttribute('href');\n            const linkRel  = node.getAttribute('rel');\n            const isLink   = node.nodeName.toLowerCase() === 'link' && linkHref && linkRel && linkRel.toLowerCase().indexOf('stylesheet') !== -1;\n            const isSkip   = settings.skipDisabled === false ? false : node.disabled;\n            const isStyle  = node.nodeName.toLowerCase() === 'style';\n\n            if (isLink && !isSkip) {\n                const isURIScheme = linkHref.indexOf('data:text/css') !== -1;\n\n                if (isURIScheme) {\n                    let cssText = decodeURIComponent(linkHref.substring(linkHref.indexOf(',') + 1));\n\n                    if (settings.useCSSOM) {\n                        cssText = Array.apply(null, node.sheet.cssRules)\n                            .map(rule => rule.cssText)\n                            .join('');\n                    }\n    \n                    handleSuccess(cssText, i, node, location.href);\n                } else {\n                    getUrls(linkHref, {\n                        mimeType: 'text/css',\n                        onBeforeSend(xhr, url, urlIndex) {\n                            settings.onBeforeSend(xhr, node, url);\n                        },\n                        onSuccess(cssText, url, urlIndex) {\n                            // Convert relative linkHref to absolute url\n                            const sourceUrl = getFullUrl(linkHref);\n    \n                            handleSuccess(cssText, i, node, sourceUrl);\n                        },\n                        onError(xhr, url, urlIndex) {\n                            cssArray[i] = '';\n                            settings.onError(xhr, node, url);\n                            handleComplete();\n                        }\n                    });\n                }\n            }\n            else if (isStyle && !isSkip) {\n                let cssText = node.textContent;\n\n                if (settings.useCSSOM) {\n                    cssText = Array.apply(null, node.sheet.cssRules)\n                        .map(rule => rule.cssText)\n                        .join('');\n                }\n\n                handleSuccess(cssText, i, node, location.href);\n            }\n            else {\n                cssArray[i] = '';\n                handleComplete();\n            }\n        });\n    }\n    else {\n        settings.onComplete('', []);\n    }\n}\n\n\n// Functions (Private)\n// =============================================================================\n/**\n * Returns fully qualified URL from relative URL and (optional) base URL\n *\n * @param {any} url\n * @param {any} base\n * @returns\n */\nfunction getFullUrl(url, base) {\n    const d = document.implementation.createHTMLDocument('');\n    const b = d.createElement('base');\n    const a = d.createElement('a');\n\n    d.head.appendChild(b);\n    d.body.appendChild(a);\n    b.href = base || document.baseURI || (document.querySelector('base') || {}).href || location.href;\n    a.href = url;\n\n    return a.href;\n}\n\n/**\n * Ponyfill for native Element.matches method\n *\n * @param   {object} elm The element to test\n * @param   {string} selector The CSS selector to test against\n * @returns {boolean}\n */\nfunction matchesSelector(elm, selector) {\n    /* istanbul ignore next */\n    const matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;\n\n    return matches.call(elm, selector);\n}\n\n\n// Export\n// =============================================================================\nexport default getCssData;\n"],"names":["getUrls","urls","options","settings","mimeType","onBeforeSend","Function","prototype","onSuccess","onError","onComplete","urlArray","Array","isArray","urlQueue","apply","length","map","x","isValidCss","text","isString","isHTML","trim","charAt","xhr","urlIndex","responseText","returnVal","indexOf","parser","document","createElement","forEach","url","i","setAttribute","href","String","isIElte9","Boolean","all","window","atob","isIElte9CORS","host","split","location","isSameProtocol","protocol","xdr","XDomainRequest","open","timeout","onprogress","ontimeout","onload","onerror","err","setTimeout","send","console","warn","concat","XMLHttpRequest","overrideMimeType","onreadystatechange","readyState","status","getCssData","regex","cssComments","cssImports","rootElement","include","exclude","filter","skipDisabled","useCSSOM","sourceNodes","querySelectorAll","node","matchesSelector","cssArray","handleComplete","isComplete","reduce","skipIndices","value","push","reverse","skipIndex","arr","splice","cssText","join","handleSuccess","cssIndex","sourceUrl","undefined","resolveImports","resolvedCssText","errorData","data","test","parseImportData","baseUrl","ignoreRules","importData","rules","replace","match","rule","absoluteUrls","getFullUrl","absoluteRules","oldUrl","newUrl","callbackFn","__errorData","__errorRules","responseImportData","responseArray","importText","linkHref","getAttribute","linkRel","isLink","nodeName","toLowerCase","isSkip","disabled","isStyle","isURIScheme","decodeURIComponent","substring","sheet","cssRules","textContent","base","d","implementation","createHTMLDocument","b","a","head","appendChild","body","baseURI","querySelector","elm","selector","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call"],"mappings":";;;;;;;AAwBA,SAASA,QAAQC;IAAMC,IAAAA,8EAAU;IAC7B,IAAMC,WAAW;QACbC,UAAcF,QAAQE,YAAgB;QACtCC,cAAcH,QAAQG,gBAAgBC,SAASC;QAC/CC,WAAcN,QAAQM,aAAgBF,SAASC;QAC/CE,SAAcP,QAAQO,WAAgBH,SAASC;QAC/CG,YAAcR,QAAQQ,cAAgBJ,SAASC;;IAEnD,IAAMI,WAAWC,MAAMC,QAAQZ,QAAQA,OAAO,EAACA;IAC/C,IAAMa,WAAWF,MAAMG,MAAM,MAAMH,MAAMD,SAASK,SAASC,KAAI,SAAAC;QAAC,OAAI;;IAI3DC,SAAAA,WAAWC;QAChB,IAAMC,kBAAkBD,SAAS;QACjC,IAAME,SAASD,YAAYD,KAAKG,OAAOC,OAAO,OAAO;QAE9CH,OAAAA,aAAaC;;IAGxB,SAASb,QAAQgB,KAAKC;QAClBvB,SAASM,QAAQgB,KAAKd,SAASe,WAAWA;;IAG9C,SAASlB,UAAUmB,cAAcD;QAC7B,IAAME,YAAYzB,SAASK,UAAUmB,cAAchB,SAASe,WAAWA;QAEvEC,eAAeC,cAAc,QAAQ,KAAKA,aAAaD;QACvDb,SAASY,YAAYC;QAGjBb,IAAAA,SAASe,QAAQ,WAAW,GAAG;YAC/B1B,SAASO,WAAWI;;;IAM5B,IAAMgB,SAASC,SAASC,cAAc;IAEtCrB,SAASsB,SAAQ,SAACC,KAAKC;QACnBL,OAAOM,aAAa,QAAQF;QAC5BJ,OAAOO,OAAOC,OAAOR,OAAOO;QAE5B,IAAME,WAAeC,QAAQT,SAASU,QAAQC,OAAOC;QAC/CC,IAAAA,eAAeL,YAAYT,OAAOe,KAAKC,MAAM,KAAK,OAAOC,SAASF,KAAKC,MAAM,KAAK;QAGxF,IAAIF,cAAc;YACRI,IAAAA,iBAAiBlB,OAAOmB,aAAaF,SAASE;YAEpD,IAAID,gBAAgB;gBAChB,IAAME,MAAM,IAAIC;gBAGhBD,IAAIE,KAAK,OAAOlB;gBAEhBgB,IAAIG,UAAU;gBACdH,IAAII,aAAahD,SAASC;gBAC1B2C,IAAIK,YAAYjD,SAASC;gBACzB2C,IAAIM,SAAS;oBACT,IAAMpC,OAAO8B,IAAIvB;oBAEjB,IAAIR,WAAWC,OAAO;wBAClBZ,UAAUY,MAAMe;2BAEf;wBACD1B,QAAQyC,KAAKf;;;gBAGrBe,IAAIO,UAAU,SAASC;oBACnBjD,QAAQyC,KAAKf;;gBAKjBwB,YAAW;oBACPT,IAAIU;oBACL;mBAEF;gBAEDC,QAAQC,KAAR,gFAAAC,OAA6F7B,KAA7F;gBACAzB,QAAQ,MAAM0B;;eAIjB;YACD,IAAMV,MAAM,IAAIuC;YAEhBvC,IAAI2B,KAAK,OAAOlB;YAGhB,IAAI/B,SAASC,YAAYqB,IAAIwC,kBAAkB;gBAC3CxC,IAAIwC,iBAAiB9D,SAASC;;YAGlCD,SAASE,aAAaoB,KAAKS,KAAKC;YAEhCV,IAAIyC,qBAAqB;gBACrB,IAAIzC,IAAI0C,eAAe,GAAG;oBACtB,IAAM/C,OAAOK,IAAIE;oBAGbF,IAAAA,IAAI2C,SAAS,OAAOjD,WAAWC,OAAO;wBACtCZ,UAAUY,MAAMe;2BAGf,IAAIV,IAAI2C,WAAW,KAAKjD,WAAWC,OAAO;wBAC3CZ,UAAUY,MAAMe;2BAGf;wBACD1B,QAAQgB,KAAKU;;;;YAKzBV,IAAImC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GCzEhB,UAASS,WAAWnE;IAChB,IAAMoE,QAAQ;QAEVC,aAAa;QAEbC,YAAa;;IAEjB,IAAMrE,WAAW;QACbsE,aAAcvE,QAAQuE,eAAgB1C;QACtC2C,SAAcxE,QAAQwE,WAAgB;QACtCC,SAAczE,QAAQyE,WAAgB;QACtCC,QAAc1E,QAAQ0E,UAAgB;QACtCC,cAAc3E,QAAQ2E,iBAAiB;QACvCC,UAAc5E,QAAQ4E,YAAgB;QACtCzE,cAAcH,QAAQG,gBAAgBC,SAASC;QAC/CC,WAAcN,QAAQM,aAAgBF,SAASC;QAC/CE,SAAcP,QAAQO,WAAgBH,SAASC;QAC/CG,YAAcR,QAAQQ,cAAgBJ,SAASC;;IAE7CwE,IAAAA,cAAcnE,MAAMG,MAAM,MAAMZ,SAASsE,YAAYO,iBAAiB7E,SAASuE,UAAUE,QAAO,SAAAK;QAAQ,QAACC,gBAAgBD,MAAM9E,SAASwE;;IAC9I,IAAMQ,WAAcvE,MAAMG,MAAM,MAAMH,MAAMmE,YAAY/D,SAASC,KAAI,SAAAC;QAAC,OAAI;;IAM1E,SAASkE;QACCC,IAAAA,aAAaF,SAAStD,QAAQ,WAAW;QAE/C,IAAIwD,YAAY;YAEZF,SACKG,QAAO,SAACC,aAAaC,OAAOrD;gBACrBqD,IAAAA,UAAU,IAAI;oBACdD,YAAYE,KAAKtD;;gBAGrB,OAAOoD;gBACR,IACFG,UACAzD,SAAQ,SAAA0D;gBAAa,OAAA,EAACZ,aAAaI,WAAUlD,SAAQ,SAAA2D;oBAAG,OAAIA,IAAIC,OAAOF,WAAW;;;YAEvF,IAAMG,UAAUX,SAASY,KAAK;YAE9B5F,SAASO,WAAWoF,SAASX,UAAUJ;;;IAkBtCiB,SAAAA,cAAcF,SAASG,UAAUhB,MAAMiB;QACtCtE,IAAAA,YAAYzB,SAASK,UAAUsF,SAASb,MAAMiB;QAEpDJ,UAAUlE,cAAcuE,aAAa3D,QAAQZ,eAAe,QAAQ,KAAKA,aAAakE;QAEtFM,eAAeN,SAASb,MAAMiB,YAAW,SAASG,iBAAiBC;YAC/D,IAAInB,SAASc,cAAc,MAAM;gBAE7BK,UAAUrE,SAAQ,SAAAsE;oBAAI,OAAIpG,SAASM,QAAQ8F,KAAK9E,KAAKwD,MAAMsB,KAAKrE;;gBAGhE,KAAK/B,SAASyE,UAAUzE,SAASyE,OAAO4B,KAAKH,kBAAkB;oBAC3DlB,SAASc,YAAYI;uBAGpB;oBACDlB,SAASc,YAAY;;gBAGzBb;;;;IAaZ,SAASqB,gBAAgBX,SAASY;QAASC,IAAAA,kFAAc;QACrD,IAAMC,aAAa;QAInBA,WAAWC,SAASf,QAEfgB,QAAQxC,MAAMC,aAAa,IAE3BwC,MAAMzC,MAAME,eAEV,IAEFI,QAAO,SAAAoC;YAAI,OAAIL,YAAY9E,QAAQmF,WAAW;;QAInDJ,WAAW3G,OAAO2G,WAAWC,MAAM5F,KAAI,SAAA+F;YAAQA,OAAAA,KAAKF,QAAQxC,MAAME,YAAY;;QAI9EoC,WAAWK,eAAeL,WAAW3G,KAAKgB,KAAI,SAAAiB;YAAG,OAAIgF,WAAWhF,KAAKwE;;QAIrEE,WAAWO,gBAAgBP,WAAWC,MAAM5F,KAAI,SAAC+F,MAAM7E;YACnD,IAAMiF,SAASR,WAAW3G,KAAKkC;YAC/B,IAAMkF,SAASH,WAAWN,WAAWK,aAAa9E,IAAIuE;YAEtD,OAAOM,KAAKF,QAAQM,QAAQC;;QAGhC,OAAOT;;IAeFR,SAAAA,eAAeN,SAASb,MAAMyB,SAASY;QAAYC,IAAAA,kFAAc;QAAIC,IAAAA,mFAAe;QACnFZ,IAAAA,aAAaH,gBAAgBX,SAASY,SAASc;QAGrD,IAAIZ,WAAWC,MAAM7F,QAAQ;YACzBhB,QAAQ4G,WAAWK,cAAc;gBAC7B5G,cAAaoB,SAAAA,aAAAA,KAAKS,KAAKR;oBACnBvB,SAASE,aAAaoB,KAAKwD,MAAM/C;;gBAErC1B,WAAUsF,SAAAA,UAAAA,SAAS5D,KAAKR;oBACdE,IAAAA,YAAYzB,SAASK,UAAUsF,SAASb,MAAM/C;oBAEpD4D,UAAUlE,cAAc,QAAQ,KAAKA,aAAakE;oBAE5C2B,IAAAA,qBAAqBhB,gBAAgBX,SAAS5D,KAAKsF;oBAGzDC,mBAAmBZ,MAAM5E,SAAQ,SAAC+E,MAAM7E;wBACpC2D,UAAUA,QAAQgB,QAAQE,MAAMS,mBAAmBN,cAAchF;;oBAGrE,OAAO2D;;gBAEXrF,SAAQgB,SAAAA,QAAAA,KAAKS,KAAKR;oBACd6F,YAAY9B,KAAK;wBAAEhE,KAAAA;wBAAKS,KAAAA;;oBACxBsF,aAAa/B,KAAKmB,WAAWC,MAAMnF;oBAEnC0E,eAAeN,SAASb,MAAMyB,SAASY,YAAYC,aAAaC;;gBAEpE9G,YAAWgH,SAAAA,WAAAA;oBACPA,cAAczF,SAAQ,SAAC0F,YAAYxF;wBAC/B2D,UAAUA,QAAQgB,QAAQF,WAAWC,MAAM1E,IAAIwF;;oBAGnDvB,eAAeN,SAASb,MAAMyB,SAASY,YAAYC,aAAaC;;;eAKvE;YACDF,WAAWxB,SAASyB;;;IAMxBxC,IAAAA,YAAY/D,QAAQ;QACpB+D,YAAY9C,SAAQ,SAACgD,MAAM9C;YACvB,IAAMyF,WAAW3C,KAAK4C,aAAa;YACnC,IAAMC,UAAW7C,KAAK4C,aAAa;YAC7BE,IAAAA,SAAW9C,KAAK+C,SAASC,kBAAkB,UAAUL,YAAYE,WAAWA,QAAQG,cAAcpG,QAAQ,mBAAmB;YACnI,IAAMqG,SAAW/H,SAAS0E,iBAAiB,QAAQ,QAAQI,KAAKkD;YAC1DC,IAAAA,UAAWnD,KAAK+C,SAASC,kBAAkB;YAEjD,IAAIF,WAAWG,QAAQ;gBACbG,IAAAA,cAAcT,SAAS/F,QAAQ,sBAAsB;gBAE3D,IAAIwG,aAAa;oBACb,IAAIvC,UAAUwC,mBAAmBV,SAASW,UAAUX,SAAS/F,QAAQ,OAAO;oBAExE1B,IAAAA,SAAS2E,UAAU;wBACnBgB,UAAUlF,MAAMG,MAAM,MAAMkE,KAAKuD,MAAMC,UAClCxH,KAAI,SAAA+F;4BAAQA,OAAAA,KAAKlB;4BACjBC,KAAK;;oBAGdC,cAAcF,SAAS3D,GAAG8C,MAAMlC,SAASV;uBACtC;oBACHrC,QAAQ4H,UAAU;wBACdxH,UAAU;wBACVC,cAAaoB,SAAAA,aAAAA,KAAKS,KAAKR;4BACnBvB,SAASE,aAAaoB,KAAKwD,MAAM/C;;wBAErC1B,WAAUsF,SAAAA,UAAAA,SAAS5D,KAAKR;4BAEpB,IAAMwE,YAAYgB,WAAWU;4BAE7B5B,cAAcF,SAAS3D,GAAG8C,MAAMiB;;wBAEpCzF,SAAQgB,SAAAA,QAAAA,KAAKS,KAAKR;4BACdyD,SAAShD,KAAK;4BACdhC,SAASM,QAAQgB,KAAKwD,MAAM/C;4BAC5BkD;;;;mBAKX,IAAIgD,YAAYF,QAAQ;gBACzB,IAAIpC,WAAUb,KAAKyD;gBAEfvI,IAAAA,SAAS2E,UAAU;oBACnBgB,WAAUlF,MAAMG,MAAM,MAAMkE,KAAKuD,MAAMC,UAClCxH,KAAI,SAAA+F;wBAAQA,OAAAA,KAAKlB;wBACjBC,KAAK;;gBAGdC,cAAcF,UAAS3D,GAAG8C,MAAMlC,SAASV;mBAExC;gBACD8C,SAAShD,KAAK;gBACdiD;;;WAIP;QACDjF,SAASO,WAAW,IAAI;;;;AAchC,SAASwG,WAAWhF,KAAKyG;IACfC,IAAAA,IAAI7G,SAAS8G,eAAeC,mBAAmB;IACrD,IAAMC,IAAIH,EAAE5G,cAAc;IAC1B,IAAMgH,IAAIJ,EAAE5G,cAAc;IAE1B4G,EAAEK,KAAKC,YAAYH;IACnBH,EAAEO,KAAKD,YAAYF;IACnBD,EAAE1G,OAAOsG,QAAQ5G,SAASqH,YAAYrH,SAASsH,cAAc,WAAW,IAAIhH,QAAQU,SAASV;IAC7F2G,EAAE3G,OAAOH;IAEF8G,OAAAA,EAAE3G;;;AAUb,SAAS6C,gBAAgBoE,KAAKC;IAEpBC,IAAAA,UAAUF,IAAIE,WAAWF,IAAIpE,mBAAmBoE,IAAIG,yBAAyBH,IAAII,sBAAsBJ,IAAIK,qBAAqBL,IAAIM;IAE1I,OAAOJ,QAAQK,KAAKP,KAAKC;;;"}
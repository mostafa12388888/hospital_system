{
	"version": 3,
	"sources": [
		"events.ts"
	],
	"names": [
		"Scope",
		"arr",
		"domUtils",
		"extend",
		"is",
		"pExtend",
		"pointerUtils",
		"FakeEvent",
		"constructor",
		"originalEvent",
		"this",
		"currentTarget",
		"type",
		"preventOriginalDefault",
		"preventDefault",
		"stopPropagation",
		"stopImmediatePropagation",
		"getOptions",
		"param",
		"object",
		"capture",
		"passive",
		"options",
		"id",
		"install",
		"scope",
		"targets",
		"delegatedEvents",
		"documents",
		"eventsMethods",
		"add",
		"remove",
		"addDelegate",
		"selector",
		"context",
		"listener",
		"optionalArg",
		"doc",
		"delegateListener",
		"delegateUseCapture",
		"delegates",
		"delegate",
		"find",
		"d",
		"listeners",
		"push",
		"removeDelegate",
		"index",
		"matchFound",
		"length",
		"cur",
		"i",
		"fn",
		"splice",
		"supportsOptions",
		"supportsPassive",
		"eventTarget",
		"target",
		"t",
		"events",
		"addEventListener",
		"contains",
		"targetIndex",
		"findIndex",
		"hasOwnProperty",
		"typeIsEmpty",
		"typeListeners",
		"removeEventListener",
		"Object",
		"keys",
		"event",
		"fakeEvent",
		"getEventTargets",
		"element",
		"matchesSelector",
		"nodeContains",
		"parentNode",
		"document",
		"createElement"
	],
	"mappings": "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",
	"sourcesContent": [
		"import { Scope } from '@interactjs/core/scope'\nimport { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document.createElement('div').addEventListener('test', null, {\n    get capture () { return (eventsMethods.supportsOptions = true) },\n    get passive () { return (eventsMethods.supportsPassive = true) },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, t => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(type, listener as any, eventsMethods.supportsOptions ? options : options.capture)\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (eventTarget: EventTarget, type: string, listener?: 'all' | Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, t => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      }\n      else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(type, listener as any, eventsMethods.supportsOptions ? options : options.capture)\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, d => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) { return }\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) { break }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = (pointerUtils.getEventTargets(event as Event))\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (domUtils.matchesSelector(element, selector) &&\n            domUtils.nodeContains(context, eventTarget) &&\n            domUtils.nodeContains(context, element)) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) { return { capture: !!param, passive: false } }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n"
	]
}
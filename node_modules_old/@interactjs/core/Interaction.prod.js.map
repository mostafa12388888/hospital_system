{
	"version": 3,
	"sources": [
		"Interaction.ts"
	],
	"names": [
		"arr",
		"extend",
		"hypot",
		"warnOnce",
		"copyAction",
		"pointerUtils",
		"rectUtils",
		"InteractEvent",
		"PointerInfo",
		"_ProxyValues",
		"_ProxyMethods",
		"idCounter",
		"Interaction",
		"pointerMoveTolerance",
		"constructor",
		"pointerType",
		"scopeFire",
		"this",
		"interactable",
		"element",
		"rect",
		"_rects",
		"edges",
		"_scopeFire",
		"prepared",
		"name",
		"axis",
		"pointers",
		"downEvent",
		"downPointer",
		"_latestPointer",
		"pointer",
		"event",
		"eventTarget",
		"prevEvent",
		"pointerIsDown",
		"pointerWasMoved",
		"_interacting",
		"_ending",
		"_stopped",
		"_proxy",
		"simulation",
		"doMove",
		"signalArg",
		"move",
		"coords",
		"start",
		"newCoords",
		"prev",
		"cur",
		"delta",
		"velocity",
		"_id",
		"that",
		"key",
		"Object",
		"defineProperty",
		"get",
		"value",
		"args",
		"interaction",
		"pointerDown",
		"pointerIndex",
		"updatePointer",
		"pointerInfo",
		"type",
		"action",
		"interacting",
		"length",
		"options",
		"enabled",
		"getRect",
		"left",
		"right",
		"top",
		"bottom",
		"_doPhase",
		"phase",
		"pointerMove",
		"modification",
		"endResult",
		"duplicateMove",
		"page",
		"x",
		"y",
		"client",
		"dx",
		"dy",
		"getPointerIndex",
		"duplicate",
		"setCoordVelocity",
		"copyCoords",
		"setZeroCoords",
		"pointerUp",
		"curEventTarget",
		"test",
		"end",
		"removePointer",
		"documentBlur",
		"endPhaseResult",
		"stop",
		"currentAction",
		"pointerId",
		"getPointerId",
		"findIndex",
		"curPointer",
		"id",
		"getPointerInfo",
		"down",
		"push",
		"setCoords",
		"map",
		"p",
		"_now",
		"setCoordDeltas",
		"downTime",
		"timeStamp",
		"downTarget",
		"pointerExtend",
		"_updateLatestPointer",
		"splice",
		"destroy",
		"_createPreparedEvent",
		"preEnd",
		"_fireEvent",
		"iEvent",
		"fire",
		"addEdges",
		"deltaSource",
		"width",
		"height",
		"Date",
		"now"
	],
	"mappings": "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",
	"sourcesContent": [
		"import type { ActionDefaults } from '@interactjs/core/defaultOptions'\nimport { Element, EdgeOptions, PointerEventType, PointerType, FullRect, CoordsSet } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { InteractEvent, EventPhase } from './InteractEvent'\nimport { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport { ActionName, Scope } from './scope'\n\nexport interface ActionProps<T extends ActionName | null = never> {\n  name: T\n  axis?: 'x' | 'y' | 'xy' | null\n  edges?: EdgeOptions | null\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = ''\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = ''\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<null>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName = ActionName> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Element = null\n  rect: FullRect\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name : null,\n    axis : null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(\n    function (this: Interaction, signalArg: any) {\n      this.move(signalArg)\n    },\n    'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: {\n    pointerType?: string\n    scopeFire: Scope['fire']\n  }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () { return that[key] },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (this.interacting() ||\n        !this.pointerIsDown ||\n        this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n        !interactable.options[action.name as keyof ActionDefaults].enabled) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element      = element\n    this.rect         = interactable.getRect(element)\n    this.edges        = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped     = false\n    this._interacting = this._doPhase({\n      interaction: this,\n      event: this.downEvent,\n      phase: 'start',\n    }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove = (this.coords.cur.page.x === this.coords.prev.page.x &&\n                           this.coords.cur.page.y === this.coords.prev.page.y &&\n                           this.coords.cur.client.x === this.coords.prev.client.x &&\n                           this.coords.cur.client.y === this.coords.prev.client.y)\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend({\n      pointer: this._latestPointer.pointer,\n      event: this._latestPointer.event,\n      eventTarget: this._latestPointer.eventTarget,\n      interaction: this,\n    }, signalArg || {})\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', { event, type: 'blur', interaction: this })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return (this.pointerType === 'mouse' || this.pointerType === 'pen')\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, curPointer => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false\n      ? false\n      : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(\n        id,\n        pointer,\n        event,\n        null,\n        null,\n      )\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    }\n    else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(this.coords.cur, this.pointers.map(p => p.pointer), this._now())\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) { return }\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (event: PointerEventType, phase: P, preEnd?: boolean, type?: string) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> }) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type)\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') { this.prevEvent = iEvent }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () { return Date.now() }\n}\n\nexport default Interaction\nexport { PointerInfo }\n"
	]
}